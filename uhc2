#!/usr/bin/perl -w

use strict;
use warnings;
use POSIX;
use File::Pid;
use Config::IniFiles;
use RPC::XML::Client;
use RPC::XML;
use OW;
use DBI;
use interfaces;
use modules;

# make "mydaemon.log" file in /var/log/ with "chown root:adm mydaemon"

my $daemonName    = "uhc2";
my $logfile       = "uhc2";

my $dieNow        = 0;                                     # used for "infinte loop" construct - allows daemon mode to gracefully exit
my $sleepMainLoop = 15;                                    # refresh main loop
my $logging       = 0;                                     # 1= logging is on
my $logFilePath   = "/var/log/";                           # log file path
my $logFile       = $logFilePath . $logfile . ".log";
my $pidFilePath   = "/var/run/";                           # PID file path
my $pidFile       = $pidFilePath . $daemonName . ".pid";

# Konfigurationsdatei einlesen
my $cfg = Config::IniFiles->new( -file => "/opt/uhc2/config.ini" );

# Verbindung mit 1-Wire Busmaster herstellen
OW::init($cfg->val( 'main', 'device' ));

# Verbindung zu MySQL Datenbank herstellen
my $database = $cfg->val( 'db', 'database' );
my $host = $cfg->val( 'db', 'host' );
my $port = $cfg->val( 'db', 'port' );
my $user = $cfg->val( 'db', 'user' );
my $pw = $cfg->val( 'db', 'pw' );
my $dsn = "dbi:mysql:$database:$host:$port";
my $dbh = DBI->connect($dsn,$user,$pw);{ RaiseError => 1} or die $dbh->errstr();

# Datenbank anlegen
$dbh->do("CREATE TABLE IF NOT EXISTS `$database`.`CurrentStates` (
               Id INTEGER AUTO_INCREMENT,
               Interface VARCHAR(255),
               Address VARCHAR(255),
               Datapoint VARCHAR(255),
               Value FLOAT,
               LastUpdate VARCHAR(255),
               PRIMARY KEY (Id))"
               ) or die $dbh->errstr();
$dbh->do("CREATE TABLE IF NOT EXISTS `$database`.`HistoryStates` (
                Id INTEGER AUTO_INCREMENT,
                Interface VARCHAR(255),
                Address VARCHAR(255),
                Datapoint VARCHAR(255),
                Value FLOAT,
                LastUpdate VARCHAR(255),
                PRIMARY KEY (Id))"
                ) or die $dbh->errstr();

my $parent = $$;
my $child = fork();

        if ($child) {
                wait;
                ccu_start();
        } else {
                server_start();
                exit(0);
        }

# daemonize
use POSIX qw(setsid);
chdir '/';
umask 0;
open STDIN,  '/dev/null'   or die "Can't read /dev/null: $!";
open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!";
defined( my $pid = fork ) or die "Can't fork: $!";
exit if $pid;

# dissociate this process from the controlling terminal that started it and stop being part
# of whatever process group this process was a part of.
POSIX::setsid() or die "Can't start a new session.";

# callback signal handler for signals.
$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signalHandler;
$SIG{PIPE} = 'ignore';

# create pid file in /var/run/
my $pidfile = File::Pid->new( { file => $pidFile, } );

$pidfile->write or die "Can't write PID file, /dev/null: $!";

# turn on logging
if ($logging) {
        open LOG, ">>$logFile";
        select((select(LOG), $|=1)[0]); # make the log file "hot" - turn off buffering
}

# "infinite" loop where some useful process happens
until ($dieNow) {

        owfs();

sleep($sleepMainLoop);
}

# add a line to the log file
sub logEntry {
        my ($logText) = @_;
        my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);
        my $dateTime = sprintf "%4d-%02d-%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
        if ($logging) {
                print LOG "$dateTime $logText\n";
        }
}

# catch signals and end the program if one is caught.
sub signalHandler {
        $dieNow = 1;    # this will cause the "infinite loop" to exit
        # Verbindung zum 1-Wire Busmaster trennen
        OW::finish();
        # CCU Abmelden '
        ccu_stop();
        # XML::RPC Server beenden
        server_stop();
}

# do this stuff when exit() is called.
END {
        if ($logging) { close LOG }
        $pidfile->remove if defined $pidfile;
}
